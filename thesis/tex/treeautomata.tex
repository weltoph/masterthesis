\section{Automata on Infinite Trees}
In Section \ref{sec:wordautomata} it is noted that word automata attach to a
word a sequence of states. The idea of classic tree automata is to attach
states to more complex structures, namely trees. For a finite set of
directions $D$ and a finite alphabet $\Sigma$ we define a $D$-ary $\Sigma$-tree
$t:D^{*}\rightarrow\Sigma$. A tree automaton produces a tree of states
which is attached to the input tree, hence a $D$-ary $Q$-tree where $Q$ is the
set of states. The following introduction conceptually follows 
\cite[Chapter 8]{AutoLogInfGames}
\begin{definition}[Tree automaton]
  Let $Q$ be a finite set of states and $q_{0}\in Q$ be one initial state.
  Furthermore, let $\Delta$ denote a set of transitions of the form
  $\tuple{q,\sigma, \tuple{q_{d}}_{d\in D}}$ where $q\in Q, q_{d}\in Q$ for
  all $d\in D$ and $\sigma\in\Sigma$. Thus, define a tree automaton
  \begin{equation*}
    \mathcal{A} = \tuple{Q, q_{0}, D, \Sigma, \Delta, \Acc\subseteq Q^{\omega}}.
  \end{equation*}
  And its semantics with the following auxillary notions
  \begin{description}
    \item[Run] a run of $\mathcal{A}$ on a $D$-ary $\Sigma$-tree $t$ is a
      $D$-ary $Q$-tree $r$ such that $r(\epsilon) = q_{0}$ and for every 
      $u\in D^{*}$ there is one 
      $\tuple{q,\sigma, \tuple{q_{d}}_{d\in D}}\in\Delta$ with $r(ud) = q_{d}$,
    \item[Acceptance Condition] the acceptance condition $\Acc$ is considered
      to be represented as B端chi-, Parity-, Muller- or Rabin-condition,
    \item[Projection of a tree] for any $\alpha=\alpha_{1}\alpha_{2}\dots\in
      D^{\omega}$ and any $D$-ary $\Sigma$-tree $t$ let $t(\alpha)$ denote the 
      word $\beta = \beta_{0}\beta_{1}\dots\in\Sigma^{\omega}$ such that for 
      every $i\in\mathbb{N}_{>0}$ holds 
      $\beta_{i} = t(\alpha_{1}\dots\alpha_{i})$ and $\beta_{0} = t(\epsilon)$.
  \end{description}
  $\mathcal{A}$ accepts a tree $t$ if there exists a run $r$ of $\mathcal{A}$
  on $t$ such that for every $\alpha\in D^{\omega}$ $r(\alpha)\in\Acc$.
\end{definition}
We introduce as we are already accustomed fitting acronyms, e.g.
\acuse{PTA}  \acuse{RTA}  \acuse{MTA} \acuse{BTA}, and present an easy example 
to familiarize ourselves with the notions of tree automata
\begin{example}
  Consider $\mathcal{L}_{\exists a}$ as the language of those binary trees over 
  the $\set{a,b}$ that contain at least one $a$. This language can be accepted 
  by a tree automaton by non-deterministically choosing a path to an occurence 
  of an $a$ and rendering every other path accepted. And the chosen path 
  accepted from the point onwards where an $a$ occured. The corresponding tree 
  automaton can be described by two states $q_{s}, q_{a}$, where $q_{s}$ is a 
  state that searches for an $a$ while $q_{a}$ is a state that renders all its 
  subtrees accepting. $q_{a}$ reproduces itself into all its subtrees, while 
  $q_{s}$ reproduces itself only in one of its subtrees and 
  \enquote{dismissing} the other one by sending $q_{a}$ in it. The acceptance 
  condition is described as a B端chi condition by the set $F = \set{q_{a}}$, 
  thus, since $q_{a}$ only produces $q_{a}$ in all following subtrees, it can 
  be also understood as a reachability condition. This yields the tree 
  automaton
  \begin{equation*}
    \mathcal{A}_{\exists a} = \tuple{Q = \set{q_{s}, q_{a}}, q_{s},
    \Delta ,F = \set{q_{a}}}
  \end{equation*}
  with
  \begin{equation*}
    \Delta = \set{\tuple{q_{a}, a, q_{a}, q_{a}},\tuple{q_{a}, b, q_{a}, q_{a}},
      \tuple{q_{s}, b, q_{s}, q_{a}}, \tuple{q_{s}, b, q_{a}, q_{s}},
      \tuple{q_{s}, a, q_{a}, q_{a}}}.
  \end{equation*}
  For all trees in $\mathcal{L}_{\exists a}$ the automaton
  $\mathcal{A}_{\exists a}$ can produce an accepting run by \enquote{guessing}
  a path to the occurence of $a$ while every tree accepted by
  $\mathcal{A}_{\exists a}$ does need to contain an $a$ since otherwise $q_{s}$
  is never transformed into $q_{a}$ which yields one non-accepting path in any
  run. Enforcing, that $q_{s}$ always reproduces into both subtrees yields an
  automaton which recognizes the language of those trees which do have an $a$
  on every branch. We denote this language as $\mathcal{L}_{\forall a}$.
  \label{ex:treeexa}
\end{example}
It is noteworthy that $\mathcal{A}_{\exists a}$ uses a very simple acceptance
condition, namely a reachability condition which is emulated by a B端chi
condition. The following example on the other hand uses a more elaborate
acceptance condition:
\begin{example}
  This example is similiar to e.g.
  \cite[Exercise 8.3 and the proof of Theorem 8.6]{AutoLogInfGames}.
  Let $\mathcal{L}_{\not\infty a}$ be the language of all binary trees over the
  set $\set{a,b}$ that contain on every path only finitely many $a$. Note the
  similarity to Example \ref{ex:fina} for word automata. This
  language can be recognized by tree automata with a very easy structure,
  namely there are two states $q_{a}, q_{b}$ which only are visited if the
  corresponding letter is read. Thus, we define
  \begin{equation*}
    \Delta = \set{
      \tuple{q_{a}, a, q_{a}, q_{a}},
      \tuple{q_{b}, a, q_{a}, q_{a}},
      \tuple{q_{a}, b, q_{b}, q_{b}},
      \tuple{q_{b}, b, q_{b}, q_{b}}
    }.
  \end{equation*}
  Any Rabin-, Muller- or Parity-condition as described in Example \ref{ex:fina}
  accepts the correct language since these precisely define the abscence of
  infinitely many occurences of $q_{a}$.

  For the corresponding \ac{NBA} in Example \ref{ex:fina} we used a structural
  way to model the abscence of further occurences of $a$ from one point 
  onwards.  This argument of guessing the moment when no further $a$ appears 
  cannot be used in the case of trees since every such guess involves the 
  complete subtree. Considering the tree $t:\set{0,1}*\rightarrow\set{a,b}$ 
  with $t(w) = a$ if and only if $w = 1^{n}0$ for any $n\in\mathbb{N}_{>0}$ we 
  see that $t\in\mathcal{L}_{\not\infty a}$, but for all $k\in\mathbb{N}_{>0}$ 
  the subtree rooted in $1^{k}$ contains an $a$. Thus, there is no point from
  which this subtree is $a$-free, therefore this idea of guessing such a point 
  does not translate to tree automata.
\end{example}
The difficulties to define a \ac{BTA} to accept $\mathcal{L}_{\not\infty a}$ 
are inherent to the B端chi-condition. In fact it is possible to show that 
$\mathcal{L}_{\not\infty a}$ cannot be accepted by any \ac{BTA}, thus 
separating the expressiveness of tree automata as in
\begin{theorem}
  \cite[Corollary 8]{WeakDefRel} cited after
  \cite[Theorem 8.6]{AutoLogInfGames}.
  \acp{BTA} are strictly weaker than \ac{MTA} in the sense that there exists 
  a language recognizable by a \ac{MTA} but not recognizable by a \ac{BTA}.
\end{theorem}
This is in contrast to Theorem \ref{thm:omegaregularexp} where we could use the
non-determinism of an \ac{NBA} to emulate a more expressive acceptance 
condition, e.g. a Muller-condition. But by the same techniques as for the proof 
of Theorem \ref{thm:omegaregularexp} for the equivalence of the 
\enquote{strong} acceptance conditions, namely \acp{LAR}, we can ensure
\begin{theorem}
  \cite[Theorem 8.7]{AutoLogInfGames}
  \acp{MTA}, \acp{RTA} and \acp{PTA} all recognize the same tree languages.
  \label{thm:treeautoequiv}
\end{theorem}
Regarding the closure properties of this class of tree languages it is again
possible to show its closure under union, intersection and negation. This gives
\begin{theorem}
  \cite[Theorem 1.3]{SOTheoAndTrees}
  \cite[Theorem 1.5]{SOTheoAndTrees}
  The class of languages that can be accepted by \acp{MTA}, \acp{RTA} and 
  \acp{PTA} forms a Boolean-algebra. The transformations can be effectively
  constructed.
  \label{thm:treeautoboolean}
\end{theorem}
We do not state the proof explicitly since the used concepts for union and
intersection are the same as for the proof Theorem \ref{thm:omegaregboolean},
namely we can obtain union by constructing an automaton that performs an 
initial \emph{guess} which input automata is simulated and an automaton for the
intersection simulates both input automata by a a product construction and uses 
a Muller-condition which formulates the acceptance of the individual components 
by their original acceptance conditions. In order to convey the closure under
negation we introduce further concepts regarding tree automata which allow to
present a proof in a natural way.

\subsection{Alternating Tree Automata}
\label{subsec:ata}
Up to this point the used automata mirrored the structure of their inputs
very closely. Word automata generated words of states and tree automata 
generated trees of states of the same arity of their input trees. This notion 
can be relaxed for tree automata to obtain a new class of tree
automata, that is \emph{Alternating Tree Automata}. Following 
\cite{AltTreeAuto} tree automata operate by sending down \enquote{copies} 
through the different paths. In the classical setting at every branching point 
every successor is awarded with one copy of a state of the automaton. The 
aforementioned relaxation lies in the idea to allow at a branching point to 
award some successor with more than one state while others may not receive even 
a single one. This concept is also used to define automata that run over 
transition systems, e.g. \cite[Chapter 9]{AutoLogInfGames} and 
\cite{SynProbEnv}, where the input tree is the unrollment of the transition 
system.

Formally, before transitions for tree automata are defined as tuples of the 
form $\tuple{q, \sigma, \tuple{q_{d}}_{d\in D}}$. This specifically defines for
every direction one single state to move along this direction. We introduce
transitions of the form $\tuple{q,\sigma,\delta_{A}}$ where $\delta_{A}$ is a 
characteristic function of a non-empty subset $A\subseteq D\times Q$ called a
\emph{clause-function}, i.e.
\begin{equation*}
  \delta_{A}:D\times Q\rightarrow\set{0,1}\text{ with }
  \delta_{A}(a) = \begin{cases}
    1&\text{if }a\in A,\\
    0&\text{if }a\notin A.
  \end{cases}
\end{equation*}
Semantically, $\delta_{A}$ sends a copy of $q$ down the direction $d$ for every
$\tuple{d,q}\in A$. This notion allows us to refine the tree automaton of 
Example \ref{ex:treeexa}:
\begin{example}
  Recall $\mathcal{A}_{\exists a}$ from Example \ref{ex:treeexa} which
  determines if a tree contains an $a$ with 
  \begin{equation*}
    \Delta = \set{
      \tuple{q_{a}, a, q_{a}, q_{a}},
      \tuple{q_{a}, b, q_{a}, q_{a}},
      \tuple{q_{s}, a, q_{a}, q_{a}},
      \tuple{q_{s}, b, q_{s}, q_{a}},
      \tuple{q_{s}, b, q_{a}, q_{s}}
    }.
  \end{equation*}
  The concept of alternating tree automata allows to formulate the
  \enquote{searching} part of the run more concisely\footnote{
    Occasionally, e.g. in \cite[Chapter 9]{AutoLogInfGames}, alternating tree
    automata are equipped with the possibility to render a subtree accepted 
    regardless of its structure. We explicitly do not include this notion, but 
    it is easy to see that this would allow to equivalently define transitions
    $\tuple{q_{a}, a, \delta_{\top}},\tuple{q_{a}, b, \delta_{\top}},
    \tuple{q_{s}, a, \delta_{\top}}$ where $\delta_{\top}$ renders the subtree
    accepted.
  }
  by dropping the necessity to send a $q_{a}$ along the
  path that is not chosen, thus including
  \begin{equation*}
    \tuple{q_{s}, b, \delta_{\set{\tuple{0, q_{s}}}}},
    \tuple{q_{s}, b, \delta_{\set{\tuple{1, q_{s}}}}}.
  \end{equation*}
\end{example}
We formally define similar to \cite{SynProbEnv}
\begin{definition}[Alternating Tree Automata]
  For a finite set of states $Q$, one distinct intial state $q_{0}\in Q$, a
  finite set of directions $D$, a finite alphabet $\Sigma$ and a transition
  relation $\Delta$ we define 
  \begin{equation*}
    \mathcal{A} = \tuple{Q, q_{0}, D, \Sigma, \Delta, \Acc\subseteq Q^{\omega}}.
  \end{equation*}
  The semantics of $\mathcal{A}$ is given by a run $r$ of $\mathcal{A}$ on a
  $D$-ary $\Sigma$-tree $t$. Here $r$ is a $D\times Q$-ary $\nabla$-tree where 
  $\nabla$ is the set of all clause-functions occuring in $\Delta$ with the 
  following necessities:
  \begin{enumerate}
    \item $r(\epsilon) = \delta_{A}$ for 
      $\tuple{q_{0}, t(\epsilon), \delta_{A}}\in\Delta$,
    \item for every $u = \tuple{d_{1}, q_{1}}\dots\tuple{d_{n}, q_{n}}\in
      \tuple{D\times Q}^{*}$ with $r(u) = \delta_{A}$ there exists
      $\tuple{q_{n}, t(d_{1}\dots d_{n}), \delta_{A}}\in\Delta$.
  \end{enumerate}
  We consider such a run $r$ accepting if all paths that move along 
  clause-functions are part of $\Acc$. Formally, we fix for any run $r$ the set 
  of its \enquote{marked path} as
  \begin{equation*}
  M_{r} = \set{
    \tuple{d_{1}, q_{1}}\tuple{d_{2}, q_{2}}\dots\in
    \tuple{D\times Q}^{\omega}\middle|
    \begin{aligned}
      &r(\tuple{d_{1}, q_{1}}\dots
      \tuple{d_{i}, q_{i}})(d_{i+1}, q_{i+1}) = 1&\text{if }i>0\\
      &r(\epsilon)(d_{1}, q_{1}) = 1&\text{if }i=0
    \end{aligned}
    }
  \end{equation*}
  and for any $\mathcal{A}$ the set of accepted paths, i.e. those paths such 
  that a projection on its state-component yields an element in $\Acc$. We 
  define
  \begin{equation*}
    \Acc\interval{Q} = \set{
      \tuple{d_{1}, q_{1}}\tuple{d_{2}, q_{2}}\dots\in
      \tuple{D\times Q}^{\omega}\mid q_{1}q_{2}\dots\in\Acc
    }.
  \end{equation*}
  A run $r$ is considered accepting if $M_{r}\subseteq\Acc\interval{Q}$.
  Again, we consider for $\Acc$ acceptance conditions which are representable
  as B端chi-, Rabin-, Muller- or Parity-conditions and use according acronyms,
  namely \acs{ABTA}, \acs{ARTA}, \acs{AMTA}, \acs{APTA} respectively.
  \acuse{ABTA} \acuse{AMTA} \acuse{ARTA} \acuse{APTA} 
\end{definition}
By using the same argument as for Theorem 
\ref{thm:omegaregularexp} and Theorem \ref{thm:treeautoequiv} we obtain
\begin{theorem}
  \ac{ARTA}, \ac{AMTA} and \ac{APTA} recognize the same class of languages.
  \label{thm:atreeautoequiv}
\end{theorem}
Although \emph{alternation} is an extension of the \enquote{classic} tree 
automata it turns out that it does not increase the expressibility; that is
for every alternating tree automta there is a classic tree automata which 
accepts the same language of trees.
\begin{theorem}[The Simulation Theorem]
  \cite[Theorem 1.2]{SimAltTreeAuto}
  There is an effective construction which, when given an \ac{AMTA}, produces 
  an equivalent \ac{MTA}. Furthermore, given an \ac{ABTA}, there is a way to 
  effectively construct an equivalent \ac{BTA}.
  \label{thm:treesimulation}
\end{theorem}
This result and the apparent observation that alternation does not weaken the 
formalism to accept trees allows to translate the closure properties stated in 
Theorem \ref{thm:treeautoboolean} to alternating tree automata as well. Thus, 
we obtain that there are effectively constructable transformations for the 
union, intersection and complement of tree languages accepted by \ac{AMTA}. 
Nevertheless, we want to present one construction for the closure under 
intersection because it allows us to relate concepts of \acp{PBA} and of
alternation.
\begin{corollary}
  The class of languages of infinite trees that can be recognized by \acp{AMTA}
  is closed under intersection.
  \label{cor:treeintersection}
\end{corollary}
\begin{proof}[Alternative Proof]
  Given two \acp{AMTA}
  \begin{equation*}
    \mathcal{A}_{1} = \tuple{Q, q_{0}, D, \Sigma, \Delta_{1}, \mathcal{F}_{1}}
      \text{ and }
    \mathcal{A}_{2} = \tuple{P, p_{0}, D, \Sigma, \Delta_{2}, \mathcal{F}_{2}}
  \end{equation*}
  we construct an \ac{AMTA} for their intersection. W.l.o.g. we assume that 
  $Q\cap P = \emptyset$. The idea is to perform two independent runs on the 
  tree in parallel. We illustrate this in Figure \ref{fig:parallelruns}. 
  Formally, it is accomplished by initially dispatching one transition of each 
  automaton onto the tree. After this initial dispatch both state sets $Q$ and
  $P$ operate independently on the tree. Hence, we define
  \begin{equation*}
    \mathcal{A}_{\cap} = \tuple{
      Q\cup P\uplus\set{q^{i}}, q^{i}, D, \Sigma, 
      \Delta_{1}\cup\Delta_{2}\cup\Delta_{\cap}, 
      \mathcal{F}_{1}\cup\mathcal{F}_{2}
    }
  \end{equation*}
  with
  \begin{equation*}
    \Delta_{\cap} = \set{
      \tuple{q^{i},\sigma,\delta_{A\cup B}}:
        \tuple{q_{0},\sigma,\delta_{A}}\in\Delta_{1}
      \text{ and }
        \tuple{p_{0},\sigma,\delta_{B}}\in\Delta_{2}
      \text{ for every }
        \sigma\in\Sigma
    }.
  \end{equation*}
  Thus, we can construct from the resulting run $r$ in $\mathcal{A}_{\cap}$ two
  individual runs in $\mathcal{A}_{1}$ and $\mathcal{A}_{2}$ respectively, e.g.
  for $\mathcal{A}_{1}$ it is the run $r_{1}$ in the $Q$-part of the domain of 
  $r$ while the initial transition in $r$ uses a $\delta_{A\cup B}$ where 
  $r_{1}$ uses $\delta_{A}$.
\end{proof}

While considering the semantics of \acp{PBA} we used a notion of considering 
individual runs and their probabilities. This can be captured very similar to 
the concept of alternation as follows: we can regard any word 
$\alpha\in\Sigma^{\omega}$ as a $\set{0}$-ary $\Sigma$-tree $t_{\alpha}$. Then 
one \ac{PBA} $\mathcal{P}$ induces a run in a tree-sense by unrolling the state
sequences of $\mathcal{P}$ around the unary tree $t_{\alpha}$. Hereby, we can
substitute the clause-functions which have a very absolute semantic (either a
path is taken or it is not) by a probability distribution. When we gather the
individual probability distributions of $\mathcal{P}$, that is set 
$\mathcal{G}$ of all functions of the form 
$G_{\sigma}^{q}:\set{0}\times Q\rightarrow\interval{0,1}$ such that
$G_{\sigma}^{q}(0, p) = \delta(q,\sigma, p)$. We can model the run of 
$\mathcal{P}$ as a $\set{0}\times Q$-ary $\mathcal{G}$-tree where the chosen
$G_{\sigma}^{q}$ one the paths $\tuple{0,q_{1}}\dots\tuple{0,q_{n}}$ are 
consistent with the current state ($q = q_{n}$) and input symbol 
($\sigma = t(0^n)$). Therefore, every path corresponds to one state sequence of 
$\mathcal{P}$ and the visited $G_{\sigma}^{q}$ on the path induce the 
associated probabilities for the peformed steps. In this sense we can use 
Figure \ref{fig:parallelruns} as illustration for the part of the union 
operator of the proof of Theorem \ref{thm:pbaboolalgebra} where the initial 
separating dispatch is in every direction tuned down by a factor of 
$\frac{1}{2}$. This intuition is later on re-visited and formally 
substantiated. In the meantime we introduce the concept of \emph{graph games} 
to obtain a transformation that constructs the \ac{AMTA} which accepts the 
negation of the language of a given \ac{AMTA}.
\fxfatal{find reference for quantor exchange}
The inherent problem with intersection is the following discrepancy: for an 
accepted tree there has to be one run such that all its paths are accepted 
while for every non-accepted tree there is for every run one path that is 
non-accepting; hence there is an exchange of quantifiers. The semantic of tree
automata does conceptually rely on the former quantifier order, that is there
is one run such that all its path are accepted. Therefore, we formulate the 
acceptance of a tree in terms of a game between two players. One player 
constructs the run to prove the existance of a valid run while the other play 
chooses the path along the run to spoil the correctness by finding a 
non-accepted path. Then we use game theoretic notions to obtain the necessary
change in the order of quantifiers.

\subsection{Graph Games}
Tree automata are closely related to graph games, e.g.
\cite[Chapter 9]{AutoLogInfGames}. Such games are held between two players in
an \emph{arena}. An arena is a directed graph where the nodes are partioned
into two sets; each set is associated with one player. A game on such an arena
begins in one node and unfolds by the choices of the players. The player to
whom the current node $v$ belongs may choose the node $u$ the game proceeds to
from the set of those nodes connected to $v$. By associating a winning
condition for one player to the game we can call a game won by this player if
the played state sequence belongs to her winning condition. In this thesis we
consider zero-sum games, i.e. if the winning condition of one player is not met
we consider the opponent victorious. This leads to the definition
\begin{definition}[Graph Games]
  \begin{description}
    \item [Arena] Let $V$ be a set of nodes which is partioned into $V_{0}$ and
      $V_{1}$ and $E\subseteq V\times V$ a set of edges, then we define an
      arena $\tuple{V, V_{0}, V_{1}, E}$.
    \item [Game] For an arena $\tuple{V, V_{0}, V_{1}, E}$ we define with a
      winning condition $\Acc$ and one distinguished initial vertex
      $v_{0}\in V$ the game
      $\tuple{\mathcal{G}, v_{0}} = \tuple{V, V_{0}, V_{1}, E, \Acc, v_{0}}$.
    \item [Play] A play for a game $\tuple{\mathcal{G}, v_{0}} = \tuple{V,
      V_{0}, V_{1}, E, \Acc}$ is any sequence $v_{0}v_{1}\dots\in
      V^{\omega}$ which starts in $v_{0}$ and where for every $i > 0$ holds
      that $v_{i}\in v_{i-1}E$.
    \item [Strategy] For $\sigma\in\set{0,1}$ we define a strategy
      $f_{\sigma}: V^{*}V_{\sigma}\rightarrow V$ where for any $w\in V^{*}$ and
      $v\in V_{\sigma}$ $f_{\sigma}(w\cdot v)\in vE$ (where $vE =
      \set{u\in V\mid\tuple{v,u}\in E}$). A play is considered winning for
      player $0$ if it belongs to $\Acc$. Notably it holds that two strategies
      $f_{0}, f_{1}$ induce a play $v_{0}v_{1}\dots$ by fixing for any $v\in V$
      the term
      \begin{equation*}
        \sigma(v) = \begin{cases}
          0&\text{if }v\in V_{0}\\
          1&\text{if }v\in V_{1}\\
        \end{cases}\text{ and enforcing }
        v_{i+1} = f_{\sigma(v_{i})}(v_{0}\dots v_{i}).
      \end{equation*}
      If a strategy for player $\sigma$ can equivalently be represented as a
      function $f:V_{\sigma}\rightarrow V$ (naturally still satisfying that
      $f(u)\in uE$ for all $u\in V_{\sigma}$) we call this strategy
      \emph{memoryless} or \emph{positional}.
    \item [Winning] We say a play $v_{0}v_{1}\dots$ is \emph{consistent} with a
      strategy $f$ for player $\sigma$ if for every $i$ with
      $v_{i}\in V_{\sigma}$ holds that $v_{i+1} = f(v_{0}\dots v_{i})$. 
      A strategy $f$ for player $\sigma$ is called a \emph{winning strategy} if
      \emph{every} play consistent with $f$ is winning for player $\sigma$.
      We denote with \emph{winning regions}
      $\mathcal{W}^{\mathcal{G}}_{\sigma}$ those nodes $v\in V$ such that
      player $\sigma$ has a winning strategy in $\tuple{\mathcal{G}, v}$.
  \end{description}
  As we are already accustomed $\Acc$ is represented in finite ways by using
  B端chi-, Rabin-, Muller- or Parity-conditions.
\end{definition}
Given any game $\mathcal{G}$ the question arises that for every node $v$ one of
the players can ensure her win by playing the correct strategy (regardless of
the strategy her opponent chooses), i.e.
$\mathcal{W}^{\mathcal{G}}_{0}\cup\mathcal{W}^{\mathcal{G}}_{1} = V$. We call
a game with this property \emph{determined}. There is a fundamental result by
Martin establishing determinacy for all Borel winning conditions for another 
kind of games\footnote{so called Gale-Stewart games} \cite{BorelDeterminacy}. 
Fortunately, this translates to graph games and allows us to state using Lemma 
\ref{lem:measureabilityAcceptance} and its Corollary \ref{cor:borelAcceptance}
that
\begin{theorem}
  \cite[Corollary 2.10]{AutoLogInfGames}
  All graph games with B端chi-, Rabin-, Muller- or Parity-condition are 
  determined.
  \label{thm:boreldet}
\end{theorem}
This result allows for the aforementioned quantifier exchange since it allows
to state that if for every strategy of one player the opponent has a winning
riposte, i.e. the position is \emph{not} in the player's winning region then it
is in the winning region of the opponent. Hence the opponent has one strategy
to win against all of the player's strategies. Additionally, for 
Parity-conditions we even obtain that the corresponding strategies are 
positional, i.e.
\begin{theorem}
  \cite[Theorem 6]{ParityGamesPosDet}
  For a graph game with a Parity-condition with finitely many parities both 
  players have positional winning strategies on their corresponding winning 
  regions.
  \label{thm:posdetparity}
\end{theorem}

As mentioned above we use graph games to model the semantics of tree automata.
Therefore, we define an acceptance game for an automaton and a tree, i.e. an 
(infinite) graph game where player $0$ (called \automaton{}) constructs a run 
of the automaton on the tree and player $1$ explores the tree and tries to find 
a path which is not accepted (conveniently called \pathfinder{}). Formally, we 
restrict ourselves to \ac{APTA} since they are sufficiently expressive and 
define (cp. \cite{treeautosurvey,AltTreeAuto})
\begin{definition}
  For a \ac{APTA} $\mathcal{A} = \tuple{Q, q_{0}, D, \Sigma, \Delta, \parity}$
  and a $D$-ary $\Sigma$-tree $t:D^{*}\rightarrow\Sigma$ we define the graph 
  game $\mathcal{G}(\mathcal{A}, t) = \tuple{V, V_{0}, V_{1}, E, 
  \parity', \tuple{q_{0},\epsilon}}$ with
  \begin{description}
    \item [Arena] 
      $V_{0} = Q\times D^{*},V_{1} = \nabla\times D^{*}$ where $\nabla$ is 
      again the set of all clause-functions occuring in $\Delta$ and 
      $V = V_{0}\cup V_{1}$,
    \item [Edges] 
      the movements of player $0$ are captured by
      \begin{equation*}
        E_{0} = \set{
          \tuple{\tuple{q, u},\tuple{\delta_{A}, u}}:\text{ for every }
          q\in Q,u\in D^{*}\text{ and }\tuple{q, t(u), \delta_{A}}\in\Delta
        }
      \end{equation*}
      and for player $1$ by
      \begin{equation*}
        E_{1} = \set{
          \tuple{\tuple{\delta_{A}, u}, \tuple{q, u\cdot d}}:\text{ for every }
          \delta_{A}\in\nabla, u\in D^{*}\text{ and }\tuple{q,d}\in A
        }.
      \end{equation*}
      Naturally, we set $E = E_{0}\cup E_{1}$,
    \item [Winning Condition]
      the associated winning condition is the projection of the old 
      condition to the state component for nodes in $V_{0}$, i.e.
      \begin{equation*}
        \parity'(\tuple{q, u}) = \parity(q),
      \end{equation*}
      and nodes in $V_{1}$ should not impact the evaluation of a game directly, 
      therefore we set their parities lower than all parities used in 
      $\mathcal{A}$:
      \begin{equation*}
        \parity'(\tuple{\delta_{A}, u}) = p_{\bot}
        \text{ for one }p_{\bot} < \min\set{\parity(q):q\in Q}.
      \end{equation*}
  \end{description}
\end{definition}
An illustration of such a game can be found in Figure 
\ref{fig:treeacceptancegame}. 

\begin{drawing}
  \caption{
    Illustration of $\mathcal{G}(\mathcal{A}, t)$ for $\mathcal{A}$ as
    defined in Example \ref{ex:treeexa} and a $\set{0,1}$-ary $\set{a,b}$-tree
    $t$ with $t(u) = a$ if and only if $u = 00$. Nodes of player $0$ are 
    circles while player $1$ plays on rectangles. Every triangle is 
    associated with one word $u\in\set{0,1}^{*}$ and labeled with $t(u)$. 
    Player $0$ may win by moving towards the $t(00)$ subgame, which is easily
    achievable since player $1$ only has trivial moves up to that point.
  }
  \label{fig:treeacceptancegame}
  \begin{center}
    \resizebox{\textwidth}{!}{%
      \includegraphics{tikz/treeacceptancegame.pdf}%
    }
  \end{center}
\end{drawing}

The central insight for this game is the 
following lemma which connects the acceptance of $\mathcal{A}$ of $t$ with the
strategies of player $0$ in $\mathcal{G}(\mathcal{A}, t)$.
\begin{lemma}
  \cite[Lemma 3.1.]{AltTreeAuto}
  The automaton $\mathcal{A}$ accepts $t$ if and onlay if player $0$ has a 
  winning strategy in the game $\mathcal{G}(\mathcal{A}, t)$.
  \label{lem:stratacceptance}
\end{lemma}
In the following we present one proof for this lemma which reveals the 
central idea behind the construction of a dual automata for a given \ac{APTA}.
\begin{proof}
  We can connect strategies $f_{0}$ for player $0$ with runs $r$ of the 
  automaton $\mathcal{A}$ on $t$ directly by stating
  \begin{equation*}
    f_{0}(\tuple{q_{0},\epsilon}\tuple{\delta_{A_{0}},\epsilon}\dots
    \tuple{\delta_{A_{n}}, u_{1}\dots u_{n-1}}\tuple{q_{n},u_{1}\dots u_{n}}) =
    \tuple{\delta_{A_{n}},u_{1}\dots u_{n}}
  \end{equation*}
  if and only if 
  \begin{equation*}
    r(\tuple{q_{1}, u_{1}}\dots\tuple{q_{n}, u_{n}}) = \delta_{A_{n}}
  \end{equation*}
  and additionally $f_{0}(\tuple{q_{0},\epsilon}) =r(\epsilon)=\delta_{A_{0}}$. 
  As mentioned before we consider player $1$ to choose a \emph{viable} path 
  through the run and checking this path for its acceptance. Thus, given a 
  strategy $f_{0}$ associated with a run $r$ we obtain for an additional 
  riposte $f_{1}$ of player $1$ one element in $M_{r}$ and for one element in 
  $M_{r}$ one strategy for player $1$. We fix pairs $f_{1}$ and $\alpha = 
  \tuple{d_{1}, q_{1}}\tuple{d_{2}, q_{2}}\dots\in M_{r}$ such that
  \begin{equation*}
    f_{1}(\tuple{p_{0},\epsilon}\tuple{\delta_{A_{0}},\epsilon}\dots
    \tuple{p_{n-1},u_{1}\dots u_{n-1}}\tuple{\delta_{A_{n}},u_{1}\dots u_{n-1}})
    = \tuple{p_{n}, u_{1}\dots u_{n}}
  \end{equation*}
  if and only if 
  \begin{equation*}
    (u_{n} = d_{n}\text{ and }q_{n} = p_{n}).
  \end{equation*}
  Notably, the strategy $f_{1}$ also describes situations that may never occur
  because of the choices of player $0$. Therefore the word $\alpha$ and $f_{1}$
  are only connected on the paths that are viable due to the choices of both
  players before. Nevertheless, the combination of two strategies $f_{0},f_{1}$ 
  gives a play 
  $\beta = \tuple{p_{0},\epsilon}\tuple{\delta_{A_{0}},\epsilon}\tuple{p_{1}, 
  u_{1}}\dots\in V^{\omega}$ in $\mathcal{G}(\mathcal{A}, t)$. Additionally,
  we obtain one associated pair of a run and one path through its domain, 
  namely $r$ and $\alpha = \tuple{d_{1}, q_{1}}\tuple{d_{2}, q_{2}}\dots\in 
  M_{r}$. By the choice of parities for states in $V_{1}$ and the connection 
  between $f_{0}$ and $r$ and $f_{1}$ and $\alpha$ respectively we get that 
  $\max\set{\parity(p_{i}):i>0} = \max\set{\parity(q_{i}):i>0}$. Hence,
  $q_{0}q_{1}\dots\in\Acc(\parity')$ if and only if 
  $p_{0}p_{1}\dots\in\Acc(\parity)$. For an accepting run $r$ we can then state
  that the associated strategy $f_{0}$ for player $0$ is winning since every
  possible riposte of player $1$ is associated with one element in $M_{r}$.
  Every element in $M_{r}$ is accepted in the Parity-condition of $\mathcal{A}$
  and therefore the resulting play in $\mathcal{G}(\mathcal{A}, t)$. On the 
  other hand we can state that the associated run $r$ for a winning strategy 
  $f_{0}$ of player $0$ indeed is accepted since all elements in $M_{r}$ are
  checked by the strategies player $1$ may choose against $f_{0}$ (which all 
  loose against the winning strategy $f_{0}$).
\end{proof}

Notably, Theorem \ref{thm:boreldet}
solves the aforementioned difficulty with exchanging quantifiers in the 
semantic of tree automata since if there exists for every strategy of player 
$0$ one successful riposte of player $1$ then player $1$ does have one strategy
to beat all answers of player $0$. On this basis we can construct the dual 
automaton by the following argument. With Lemma \ref{lem:stratacceptance} and 
Theorem \ref{thm:boreldet} we can state that $\mathcal{A}$ does not 
accept $t$ if and only if player $1$ has a winning strategy in 
$\mathcal{G}(\mathcal{A},t)$. The idea is to encode this winning strategy in
the transitions. Thus, given the game is in state $q$ and $t$ carries at the
current position the letter $\sigma$ for every choice of player $0$,
$\tuple{q,\sigma,\delta_{A_{1}}},\dots,\tuple{q,\sigma,\delta_{A_{n}}}$, player
$1$ needs an answer. All these answers are encoded in 
\begin{equation*}
  \Delta_{1} = \set{
    \tuple{q,\sigma, \delta_{B}}:B = \set{
      \tuple{p_{1}, d_{1}}\dots\tuple{p_{n},d_{n}}:\tuple{p_{i}, d_{i}}\in 
        A_{i} \text{ for }1\leq i\leq n
    }
  }.
\end{equation*}
Therefore, a run $r$ on $t$ of these transitions explores all possible 
strategies of player $0$ and the answers of player $1$. Assuming player $1$ 
does have a winning strategy all the paths in the run are not accepted. In the 
inversed acceptance condition (again obtained by adding one to every parity), 
we get that $r$ is accepted if and only if player $1$ has a winning strategy
in $\mathcal{G}(\mathcal{A}, t)$ which happens if and only if $t$ is not 
accepted by $\mathcal{A}$. This renders, given
\begin{equation*}
  \mathcal{A} = \tuple{Q, q_{0}, D, \Sigma, \Delta_{0}, \parity},
\end{equation*}
the automaton
\begin{equation*}
  \mathcal{B} = (Q, q_{0}, D, \Sigma, 
  \underbrace{\Delta_{1}}_{\text{strategy encoding transitions to }\Delta_{0}}, 
  \parity + 1)
\end{equation*}
dual to $\mathcal{A}$ and closes the argument of closure under negation for
\acp{APTA}. And by Theorem \ref{thm:treesimulation} this suffices to show the
closure of all tree automata under negation.
\begin{proposition}
  Alternating tree automata (and therefore also tree automata) are closed under
  negation.
  \label{prop:atanegation}
\end{proposition}
