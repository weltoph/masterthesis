\chapter{Languages and Automata}
It is well established to rely on finite automata to recognize languages of
infinite objects, e.g. trees or words \cite{LangAutoLog}. In this chapter we
recall some known results for languages of infinite words and infinite trees.
Furthermore, building upon the work in \cite{RandAutoInfTrees}, we introduce and
examine a new class of tree automata, called \aclp*{WDTA}, and, using theses,
present a synthesis result for \aclp*{PBA}.

\section{$\omega$-regular Languages}
Following \cite{LangAutoLog} we introduce word automata with the following
structural definition
\begin{definition}[Word Automaton]
  We define a word automaton as
  $\mathcal{A} = \tuple{Q, \Sigma, q_{0}, \Delta}$ where
  $Q$ is a set of states, $\Sigma$ a finite alphabet, $q_{0}\in Q$ is the
  initial state and $\Delta\subseteq Q\times\Sigma\times Q$ is the transition
  relation. We define some associated notions as follows:
  \begin{description}
    \item [Run]
      For a word $\alpha = \alpha_{0}\alpha{1}\dots\in\Sigma^{\omega}$ we call
      a sequence $\pi = \pi_{0}\pi_{1}\dots \in Q^{\omega}$ a run of
      $\mathcal{A}$ on $\alpha$ if $\pi_{0} = q_{0}$ and for every
      $i\in\mathbb{N}$ holds that
      $\tuple{\pi_{i}, \alpha_{i}, \pi_{i+1}}\in\Delta$
    \item [Determinism]
      We call $\mathcal{A}$ deterministic if for every pair $q\in Q$ and
      $\sigma\in\Sigma$ the set
      $\set{p\in Q\middle| \tuple{q,\sigma,p}\in\Delta}$ has at most one
      element.
  \end{description}
\end{definition}
and expand upon this structure by classifying runs on word automata as
accepting or non-accepting by the following conditions:
\begin{definition}[Acceptance Conditions]
  For a word automaton $\mathcal{A} = \tuple{Q, \Sigma, q_{0}, \Delta}$ we
  define different acceptance conditions. For this we define for a run
  $\pi = \pi_{0}\pi_{1}\dots\in Q^{\omega}$ the operator
  $\Inf$ as the set of states that occur infinitely in a run, i.e.
  \begin{equation*}
    \Inf(\pi) = \set{q\in Q\middle| \text{ there are infinitely many }
    i\in\mathbb{N} \text{ s.t. } \pi_{i} = q}
  \end{equation*}
  With this notion we define the following acceptance conditions:
  \begin{description}
    \item [B端chi] A B端chi condition is defined by a set of final states
      $F\subseteq Q$ and we call a run $\pi$ accepting if
      $\Inf(\pi)\cap F\neq\emptyset$.
    \item [Muller] Muller conditions are given as a family of state sets, i.e.
      $\mathcal{F}\subseteq 2^{F}$. A run $\pi$ is called accepting if
      $\Inf(\pi)\in\mathcal{F}$.
    \item [Rabin] This acceptance condition is represented by a set of pairs\\
      $\Omega = \set{\tuple{E_{0}, F_{0}}, \dots, \tuple{F_{n}, E_{n}}}$ and we
      call a run $\pi$ accepting if there is an $i$ s.t.
      $\Inf(\pi)\cap F_{i}\neq\emptyset$ but $\Inf(\pi)\cap E_{i} = \emptyset$.
    \item [Streett] The Streett condition is dual to the Rabin condition and
      thus also given by a set of pairs
      $\Omega = \set{\tuple{E_{0}, F_{0}}, \dots, \tuple{F_{n}, E_{n}}}$. But
      this time we want that the Rabin condition is not fulfilled, i.e. for a
      run $\pi$ and all $i$ we have either $\Inf(\pi)\cap F_{i} = \emptyset$ or
      $\Inf(\pi)\cap E_{i} \neq \emptyset$.
    \item [Parity] \fxfatal{find fitting reference} This condition is defined
      by a function
      $\parity:Q\rightarrow \mathbb{N}$. We call a run $\pi$ accepting if the
      maximum of the set $\parity(\Inf(\pi))$, which describes the pointwise
      application of $\parity$ to the set $\Inf(\pi)$, is even (note that due
      to the finiteness of $Q$, $\Inf(\pi)$ is finite as well and thus the
      maximum of $\parity(\Inf(\pi))$ exists).
  \end{description}
\end{definition}
We categorize word automata by their acceptance condition and if they are
deterministic. Thus, we call a word automaton $\mathcal{A}$ equipped with a
B端chi condition a \ac{NBA} or respectively \ac{DBA} if
$\mathcal{A}$ is deterministic. And analogously we obtain word automata for
Muller, Rabin, Streett and Parity conditions and corresponding acronyms.
\acuse{NMA}
\acuse{DMA}
\acuse{NRA}
\acuse{DRA}
\acuse{NSA}
\acuse{DSA}
\acuse{NPA}
\acuse{DPA}
It is known that all these automata (except for \acp{DBA}) do have the same
expressiveness.
\begin{theorem}
  \cite[Proposition 5.3, Theorem 5.4, Proposition 5.6]{LangAutoLog}
  \fxfatal{find more references}
  The class of recognizable languages coincides for \acp{NBA}, \acp{NMA},
  \acp{DMA}, \acp{NRA}, \acp{DRA}, \acp{NSA}, \acp{DSA}, \acp{NPA}, \acp{DPA}.
\end{theorem}

\section{Probabilistic B端chi Automata}
Upon the concept of \acp{NBA} there are approaches to substitute the
non-deterministic choices by probabilities for the choices
\cite[e.g.]{RecOmgLangProbAuto, DecProblemsForProbAuto}. In order to properly
define these automata we introduce the concept of \aclp*{MDP}. \aclp*{MDP} can
be used to model a system which reacts to the actions of an agent (often called
player) probabilisticly.\fxfatal{more references missing} More formally we use
these definitions which follow \cite{RandAutoInfTrees}:
\begin{definition}[Markov Decision Process]
  A \acl*{MDP} is modelled as tuple
  $\tuple{S, A, \tuple{\tau_{a}}_{a\in A}, s_{0}}$ where $S$ is a set of states
  and $A$ a set of actions. Given an action $a\in A$ the corresponding
  transition function $\tau_{a}:S\times S\rightarrow \interval{0,1}$ satisfies
  for every $q\in S$ that $\sum_{p\in S}\tau_{a}\tuple{q,p} = 1$.
  $s_{0}$ is the initial state. Additionally we define a few helpful
  auxilliaries:
  \begin{description}
    \item [Following States] For a state $s\in S$ we call the states in which a
      \ac{MDP} can move from into for an action $a\in A$ $a$-following states:\\
      $\follow_{a}(s) = \set{q\in S\mid \tau_{a}(s,q) > 0}$.
    \item [Cylinder] For a finite word of states $w\in S^{*}$ we define the
      corresponding cylinder as the set of all infinite state-sequences
      that can prolong $w$: $\cyl(w) = w\cdot S^{\omega}$.
    \item [Plays] We consider all infinite sequences of states
      (i.e. $S^{\omega}$) that start in $s_{0}$ a valid play. All plays
      are gathered in $\plays = \set{
        \alpha\in S^{\omega}\mid \alpha_{0} = s_{0}} = \cyl(s_{0})$.
    \item [Strategy] We define $\varphi:S^{*}\rightarrow A$ as strategy for
      a \ac{MDP}. Such a strategy models interaction with a \ac{MDP} by
      giving a specific $a\in A$ to which the \ac{MDP} reacts by $\tau_{a}$.
  \end{description}
\end{definition}
The set of cylinders of a \ac{MDP} $\mathcal{A}$ can be extended to the
smallest $\sigma$-algebra containing these cylinders
$\mathcal{F}_{\mathcal{A}}$. For these cylinders a strategy
$\varphi_{\mathcal{A}}$ induces a probability measure as follows: we fix
\begin{equation}
  \mu_{\varphi}(\cyl(w = w_{0}\dots w_{n})\cap\plays) = \begin{cases}
    \prod_{i=1}^{n-1}\tau_{\varphi(w_{0}\dots w_{i})}(w_{i}, w_{i+1}) &\text{ if }\cyl(w)\cap\plays\neq\emptyset\\
    0 &\text{ otherwise}
  \end{cases}
\end{equation}

\section{Tree Automata}
\begin{definition}[Generator]
  For a set of states $Q$ and a set of directions $D$ we call a probability
  function on $Q\times D$, i.e. $G: Q\times D\rightarrow [0,1]$ with
  $\sum\limits_{\substack{q\in Q\\ d\in D}}G(q,d) = 1$, a generator over $Q$
  and $D$. A finite set of generators over sets $Q$ and $D$ is called a clause
  $C = \set{G_{1},\dots,G_{n}}$.
\end{definition}
Adapting notions from alternating tree automata we define \emph{\ac{WDTA}} as
follows:
\begin{definition}[Weighted Descent Tree Automaton]
  We define a Weighted Descent Tree Automata as tuple
  $\mathcal{A} = \tuple{Q, q_{0}, D, \Sigma, \Delta, T}$ where $Q$ is a finite
  set of states, $q_{0}$ the initial state, $D$ a finite set of directions,
  $\Sigma$ is a finite Alphabet and $T\subseteq Q^{\omega}$ is a
  $\omega$-regular target of infinite words of elements in $Q$. The transitions
  in $\Delta$ are given as clauses for every state and symbol:
  $\Delta:Q\times\Sigma\rightarrow\mathcal{C}$
  where $\mathcal{C}$ denotes the set of all clauses over $Q$ and $D$.
\end{definition}
The semantics of a \ac{WDTA} $\mathcal{A}$ is given as a run
\fxwarning{define run as a tree of generators}
$r:q_{0}(Q\times D)\rightarrow [0,1]$ on a tree
$t:D^{*}\rightarrow\Sigma$ with $r(q_{0}) = 1$ and for a defined value
of $r(q_{0}\tuple{q_{1}, d_{1}}\dots\tuple{q_{n}, d_{n}})$ (resp. $r(q_{0})$)
there is $G\in\Delta(q_{n}, t(d_{1}\dots d_{n}))$ (resp. $G\in\Delta(q_{0},
t(\epsilon))$) such that
$r(q_{0}\tuple{q_{1}, d_{1}}\dots\tuple{q_{n}, d_{n}}\tuple{q_{n+1}, d_{n+1}})
= r(q_{0}\tuple{q_{1}, d_{1}}\dots\tuple{q_{n}, d_{n}})\cdot G(q_{n+1}, d_{n+1})$
for all $q_{n+1}\in Q$ and $d_{n+1}\in D$. Analogously to a \ac{MDP} we define
cylinders $\cyl(w) = \set{w\alpha : \alpha\in Q^{\omega}}$ for all
$w\in q_{0}(Q\times D)^{*}$ and naturally a run $r$ induces a
probability measure on these cylinders with $\mu_{r}(\cyl(w)) = r(w)$. We call
$r$ accepting if the measure of the set of those words in
$q_{0}(Q\times D)^{\omega}$ such that the projection to the states is in $T$
has a measure of 1. Naturally, we say that $\mathcal{A}$ accepts $t$ if such an
accepting run exists. Furthermore we call a \ac{WDTA} \emph{deterministic} if
there is at most one generator in each clause $\Delta(q, \sigma)$ and
\emph{unidirectional} if in each clause
$\set{G_{1},\dots,G_{n}} = \Delta(q, \sigma)$ for all $i$ there is at most one
$q\in Q$ such that $G(q, d) > 0$ for all $d\in D$. Intuitively, the automaton
explores every path with at most one state.
\fxfatal{show measurability of accepting paths}

We can now define an acceptance game $\mathcal{G}_{\mathcal{A}, t}$ for a
\ac{WDTA} $\mathcal{A}$ and a tree $t$ as \ac{MDP} (thus, it is a solitaire
game).
\begin{definition}[Acceptance Game]
  For a \ac{WDTA} $\mathcal{A}$ and a tree $t$ we define the game
  \begin{equation}
    \mathcal{G}_{\mathcal{A}, t} = \tuple{q_{0}(Q\times D)^{*}\cup\set{\bot},
    q_{0}, \mathcal{C}, \tuple{\mu_{G}}_{G\in\mathcal{C}}}
  \end{equation}
  such that the player may choose for
  $q_{0}\tuple{q_{1}, d_{1}}\dots\tuple{q_{n}, d_{1}}$ one
  $G\in\Delta(q_{n}, t(d_{1}\dots d_{n}))$ (resp.
  $G\in\Delta(q_{0}, t(\epsilon))$ in state $q_{0}$)
  and moves with probability $G(q_{n+1}, d_{n+1})$ to
  $q_{0}\tuple{q_{1}, d_{1}}\dots\tuple{q_{n}, d_{1}}\tuple{q_{n+1}, d_{n+1}}$.
  Without loss of generality we assume the target $T$ to be given by a parity
  function $\parity:Q\rightarrow \set{0,\dots, k}$ and we equip the game
  $\mathcal{G}_{\mathcal{A}, t}$ correspondingly with the parity objective given
  by $\parity'$ which projects to the parity of the last state, i.e.
  $\parity'(q_0) = \parity(q_0)$ and $\parity'(q_0\alpha\tuple{q_{l}, d_{l}}) = \parity(q_{l})$.
\end{definition}
By exploiting that the player only needs local information to make its
decisions we can define an emptiness game in similar fashion:
\begin{definition}[Emptiness Game]
  We define for a \ac{WDTA} $\mathcal{A}$ a \ac{MDP} $\mathcal{M}$ as follows:
  \begin{equation}
    \mathcal{M} = \tuple{Q\times\Sigma\cup\Delta(Q, D)\times D\cup\set{q_{0},\bot},
    q_{0}, \Delta(Q, D)\cup\Sigma, \tuple{\mu_a}_{a\in\Delta(Q, D)\cup\Sigma}}
  \end{equation}
  such that the player may choose for $\tuple{q,\sigma}$ a generator
  $G\in\Delta(Q, D)$ and the game moves with probability
  $\sum\limits_{p\in Q}G(p, d)$ to $\tuple{G, d}$ where the player now fixes
  $\sigma'\in\Sigma$ and moves to $\tuple{q', \sigma'}$ with probability
  $\frac{G(q',\sigma')}{\sum\limits_{p\in Q}G(p, d)}$. From $q_{0}$ the choice
  of a generator $G\in\bigcup\limits_{\sigma\in\Sigma}\Delta(q_{0}, \sigma)$
  moves the player to $\tuple{G, d}$ with probability
  $\sum\limits_{p\in Q}G(p, d)$.
  Every choice of the player other than described above enforces move to $\bot$
  with a probability of 1 (also, every choice in $\bot$ only allows
  for a move to $\bot$ with probability 1). The objective of the game is
  defined by $\parity'(q,d) = \parity_{\mathcal{A}}(q)$ while states of the
  form $\tuple{G, d}$ of $q_{0}$ hold a parity which is higher than all other
  parities and $\bot$ holds a losing parity. 
\end{definition}
